---
title: " JVM 内存模型"
subtitle: " JVM 虚拟机规范"
date: 2019-01-19
categories: [java, foundation]
tags: [JVM, Memory]
---

本文是对[Java Virtual Machine Specification, Java SE 11 Edition(§2.5)][1]的翻译，该章节是对 JVM 的内存模型的详细定义。

### 运行时数据区

 JVM 定义了多种用于程序执行时的运行时数据区。其中有一些是在 JVM 启动时创建，JVM 退出时销毁。其他数据区是每个线程的，它们在线程创建时创建，线程退出时销毁。

####  pc 寄存器

 JVM 支持同时执行多个线程，每个 JVM 线程都有它自己的 pc (program counter) 寄存器。在任意时间点，每个 JVM 线程都在执行一个方法的代码，也就是这个线程的当前方法（current method）。如果方法不是`native`的，那么 pc 寄存器存储了 JVM 当前执行的指令的地址。如果当前线程正在执行的方法是`native`的，那么 pc 寄存器的值为`undefined`。 JVM 中的 pc 寄存器拥有足够存储一个返回地址或者平台相关的本地地址的指针。

####  Java 虚拟机栈

每个 JVM 线程都拥有一个 Java 虚拟机栈，它和线程同时被创建，用于保存[帧][2]的集合。 Java 虚拟机栈类似与C这类传统语言中的栈：它存储本地变量和局部结果，并且参与方法的执行与返回。由于 Java 虚拟机栈除了 push 和 pop 帧以外不作其他操作，帧会被堆分配。 Java 虚拟机栈的内存空间不需要是连续的。

_在第一版的 Java 虚拟机规范中，Java 虚拟机栈被称作 Java 栈。_

本规范允许 Java 虚拟机栈取固定大小或者根据计算的需要动态扩大和缩小。如果 Java 虚拟机栈是固定大小的，其大小应该在栈被创建时独立选择。

_Java 虚拟机实现应该提供给开发者或用户控制 Java 虚拟机栈初始化大小的能力，同时，在动态扩大或缩小 Java 虚拟机栈的场景中，应该提供控制最大或最小大小的能力。_

以下异常状态是和 Java 虚拟机栈相关的：

- 如果在某个线程的计算过程中需要的 Java 虚拟机栈容量大于允许值，Java 虚拟机会抛出`StackOverflowError`。
- 如果 Java 虚拟机栈可以动态扩大，并且某次试图扩大时，没有足够的可用内存来响应这次扩大；或者如果没有足够的可用内存为一个新的线程创建初始化 Java 虚拟机栈，Java 虚拟机会抛出`OutOfMemoryError`。

#### 堆

Java 虚拟机拥有一个所有 Java 虚拟机线程共享的`heap`（堆）。堆是为所有的对象实例和数组分配内存的运行时数据区。

堆是虚拟机启动时创建的，堆存储了可以被自动存储管理系统（也就是垃圾回收器 gc ）回收的对象，对象是不会被显式地回收的。Java 虚拟机不假定某种固定类型的自动存储管理系统，可以根据实现者的系统需要来选择存储管理技术。堆可以是固定大小的，也可以是根据计算需要扩大或不需要太大时缩小。堆的内存空间不需要是连续的。

_Java 虚拟机实现应该提供给开发者或用户控制堆初始化大小的能力，同时，如果堆的大小可以动态扩大和缩小，应该提供控制最大或最小大小的能力。_

以下异常状态是和堆相关的：

- 如果计算所需的堆大于自动存储管理系统所能提供的堆，Java 虚拟机会抛出`OutOfMemoryError`。

#### 方法区

Java 虚拟机的方法区是所有 Java 线程所共享的。方法区类似于传统语言中的编译后代码的存储区或者类似于操作系统进程中的`text`段。它保存了每个类的结构，包括运行时常量池、字段和方法数据、方法的代码和构造器，构造器包括用于类和接口以及实例的初始化的特定方法。

方法区是在 Java 虚拟机启动时创建的，虽然方法区是堆的一块逻辑区域，但是在简单的实现中可能会选择不去对它进行垃圾回收或压缩。此规范不限定方法区的位置和用于管理编译后代码的策略。方法区可以是固定大小的，也可以是根据计算需要扩大或不需要太大时缩小。方法区的内存空间不需要是连续的。

_Java 虚拟机实现应该提供给开发者或用户控制方法区初始化大小的能力，同时，在可变大小方法区的场景中，应该提供控制最大或最小大小的能力。_

下异常状态是和方法区相关的：

- 如果方法区能提供的内存不满足某次内存分配的需要，Java 虚拟机会抛出`OutOfMemoryError`。

#### 运行时常量池

运行时常量池是每个类或接口的[`class`文件][3]中常量池表在运行时的表现形式。它包括几种常量，从编译期已知的数值文本到运行时需要解析的方法和字段的引用。运行时常量池的功能和传统编程语言中的符号表类似，但是它比传统的符号表包含更多的内容。

每个运行时常量池都是从 Java 虚拟机的方法区分配内存。一个类或接口的运行时常量池是在它被 Java 虚拟机创建时构造的。

以下异常状态是和类或接口的运行时常量池的构造相关的：

- 当创建类或接口时，如果运行时常量池的构造需要的内存大于当时 Java 虚拟机方法区所能提供的内存，Java 虚拟机会抛出`OutOfMemoryError`。

_[第五章（加载、连接、初始化）][4]中有运行时常量池的构造相关的信息。_

[1]: https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.5 "Java 虚拟机规范，Java SE 11 版，2.5章"
[2]: https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-2.html#jvms-2.6 "Java 虚拟机规范，Java SE 11 版，2.6章"
[3]: https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-4.html#jvms-4.4 "Java 虚拟机规范，Java SE 11 版，4.4章"
[4]: https://docs.oracle.com/javase/specs/jvms/se11/html/jvms-5.html "Java 虚拟机规范，Java SE 11 版，第五章"
